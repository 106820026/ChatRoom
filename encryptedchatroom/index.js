const express = require('express');
const app = express();
const server = require('http').Server(app);
const io = require('socket.io')(server);
const records = require('./record.js');
const crypto = require('crypto');

//主動方自己產生資料
var oneSay;
//被動方接受主動方傳過來的資料進行計算，產生握手資料和最終的祕鑰
var twoGetSay;
var encrypted_message;

app.use(express.static(__dirname));

// add online people count
let onlineCount = 0;
// if connected
io.on('connection', (socket) => {
    // add online count
    onlineCount++;
    // sent onlineCount to UI
    io.emit("online", onlineCount);
    socket.emit("maxRecord", records.getMax());
    socket.emit("chatRecord", records.get());

    // receive greet event from UI
    socket.on("greet", () => {
        socket.emit("greet", onlineCount);
    });

    // if disconnected
    socket.on('disconnect', () => {
        onlineCount = (onlineCount < 0) ? 0 : onlineCount-=1;
        io.emit('online', onlineCount);
    });

    // if send the msg
    socket.on('send', (msg) => {
      // if the length of msg less than 2, return
        if (Object.keys(msg).length < 2) return;
        oneSay=dhOneSay();
        twoGetSay=dhTwoGetSay(oneSay[0]);
        var oneSecret=dhOneGet(twoGetSay[0],oneSay[1]);
        msg.msg = aesEncode(msg.msg, oneSecret);
        encrypted_message = msg.msg;
        records.push(msg);
    });
});

records.on("new_message", (msg)=>{
    var twoSecret=twoGetSay[1];
    msg.msg = aesDecode(msg.msg, twoSecret);
    io.emit("msg", msg, encrypted_message);
});

server.listen(8080, () => {
    console.log("Server Started. http://localhost:8080");
});

///////////////////////////////////////////
// Encrypt                              //
//////////////////////////////////////////

// AES encrypt
function aesEncode(data, key) {
    const cipher = crypto.createCipher('aes192', key);
    var crypted = cipher.update(data, 'utf8', 'hex');
    crypted += cipher.final('hex'); //The encoding of the return value.
    return crypted;
  }
// AES decrypt
function aesDecode(encrypted, key) {
    const decipher = crypto.createDecipher('aes192', key);
    var decrypted = decipher.update(encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  }

///////////////////////////////////////////
// Key Generation                       //
//////////////////////////////////////////

// active one negotiate method, 'say' are the three data we want to pass to passive one and 'one' is the data for ourselves
function dhOneSay() {
    var one = crypto.createDiffieHellman(512);
    var one_key = one.generateKeys(); // Generates private and public Diffie-Hellman key values, and returns the public key
    var prime = one.getPrime();
    var generator = one.getGenerator(); // return the encoding of the return value.
    var say = {
      prime: prime, generator: generator, one_key: one_key
    };
    return [say, one];
}

// passive one get key 'theSecret', 'two_key' are the three data we want to pass to active one
function dhTwoGetSay(props) {
    var two = crypto.createDiffieHellman(props.prime, props.generator); // Creates a DiffieHellmankey exchange object using the supplied primeand an optional specific generator
    var two_key = two.generateKeys();
    var theSecret = (two.computeSecret(props.one_key)).toString('hex');
    return [ two_key, theSecret ];
}

// passive one calculate the key, 'two_key' are data generate by passive one and 'one' is the initial data generated by itself
function dhOneGet(two_key,one){
    return (one.computeSecret(two_key)).toString('hex');
}

// __dirname will return exeFile's absolute path, __filename=__dirname+exeFile
app.get('/', (req, res)=>{res.sendFile(__dirname + '/views/index.html');});